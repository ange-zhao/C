# 常见面试题问答
### 1. 程序源代码以C语言为例，是如何转换为可执行的代码（二进制代码或者说机器语言）?

C源代码 －> 预处理器 －> 编译器 －> 汇编器 -> 链接器 -> 转换为可执行的文件

```
1. C源代码经过预处理器其结果，还是C语言

2. 预处理器经过编译（句法， 词义分析， 代码的优化，代码生成），其结果是汇编代码

3. 汇编代码结过汇编器其结果是中间代码（.o），其本质上也是二进制代码

4. 中间文件（.o）经过链接器的链接， 最后生成可执行的文件。

```

### 2.Ｃ语言里比较灵活的一块内容是指针， 那么请谈谈你对指针的理解。

回答这个问题的思路：
1､什么是指针，指针的基本概念
2.指针的使用场景
3.结合具体的例子，来说明一个， 用指针来解决那些问题。
4.关于指针运算的问题。


### 3.Ｃ语言内存布局

![Mou icon](/Users/qingyun/Desktop/1411Student/文档/C程序内存布局示意图.png)
1. 代码区：主要是存放代码，也就是程序指令。这个区的数据是只读

2.数据区，已初始区，声明全局变量的时候，同时给出了值， 那么这个变量就会放到已初始化。未初始化区：BSS,对于这个区的变量， 默认情况下， 全部初始为0  

3.堆区:是程序员接触最多的区域。malloc函数就是从这个区来分配内存的， 这个区是从下往上扩展

4.栈区：是由系统来管理的内存区域。局部变量，函数调用也在这个区，先进后出。

5 . 命令参数及环境变量区


### 4.Ｃ语言中const 关键字的理解
#### a. 对于非指针变量的修饰 比int const关键字可以放到int 之前， 也可放到int之后， 如const int myInt; int const myInt;它们所表达的含义是一样的， 都是表示myInt是一个常量。 不能修改myInt的值。 我们推荐使用const int myInt;

#### b. 对于指针变量的声明， 有四种情况 以int * 为例 
```
1. const int *pMyPointer 
2. int const * pMyPointer 
3. int * const pMyPointer; 
4. const int * const pMyPointer
```
对于1、2两种情况， 所表达的含义是一样的， 表示指针指指向的内容不能修改。

对于第3种情况， 所表达的含义是说指针本身不能再指向其它地址

对于第4种情况， 表明指针指向的内容不能修改， 同时指针本身也没能再指向其它地址。

### 在继承语法中， 关于OC的方法调度机制

1､每一个对象，都有一个指针指向其类
2.当向对象发送消息， 对象准备执行方法的时候，它会先在当前对象对属的类中查找这个方法， 如果找到话就开始执行， 如果没有找到的话， 就去对象所属类的父类去查找， 如果找到就执行， 如果没有找到， 则会沿着继承链一层一层的向上去查找， 直到NSObject 类， 如果找到则执行， 如果没有找到， 则首先编译器会给出一个警告， 如果忽略了这个警告，则在运行时程序会崩溃。


### 在继承中， 子类对象是如何说父类声明的成员变量的？

在创建一个新类的时候， 其对象会首先从父类中继承成员变量， 然后添加自身的成员变量。

### 谈谈你对OC中self 和 super的理解？

1.self 首先他是一个指针。
2.当向对象发送消息， 对象去调用对应的方法的时候， 在调用方法中， 在这个方法里，隐藏传了一个指针， 这个指针就是self，这个self 代表的是调用这个方法的消息接收者。
3. 有时候， 我们需要在子类里显式的调用父的方法， 这个时候 super可以代表父类， 需要注意的是， 这个super不是指针，也不是成员变量， 而它只是编译器识别的指令， 主要就用于子类访问父类的内容。

### 请问#include "header.h" 和#include <header.h> 有什么区别？在OC中#import又有什么特点？ 

1､#include 属于预处理指令。主要功能是导入头文件内所有的内容， 其本质是将头文件的内容原封不同的复制到实现文件（.c .m .cpp .mm）
2.#import与#include的功能和本质是一样的。


3.#include "header.h" 双引号括起来。 因为要导入头文件的内容， 所以需要找到头文件的位置，对于双引号， 预处理器会首先
从当前工程的路径下去查找相应的头文件， 如果没有找到， 则去系统的头文件目录查找。 


4.#include <> 尖括号同， 预处理器会直接从系统头文件目录去查找头文件的位置	
5.#include "" 一般情况主要用于导入自定义的头文件。 #include <>主要用于导入系统头文件
那么#include预处理指令， 在文件相互依赖的时候， 容易出现重复包含的错误， 为了解决这个问题， C语言引入了头文件卫士的机制#ifndef #define #endif.		


6.#import主要的特点是， 不需要使用头文件卫士就可达到不重复包含头文件。从本质来说， 他的内容已解决了重复包含的问题， 所以在OC语言里， 我们主要推荐使用#import

### Xcode常用快捷方式

command + 0 是用于显示或者隐藏Xcode左边工程控制区	 
command + option + 0 是用于显示或者隐藏Xcode右边管理区	
command + shift + y是用于显示或者隐藏Xcode底部的调试区和控制台区	
command + / 当选中多行代码或才一行代码来快速注释功能。	
command + [ 实现代码块的左移功能		
command + ] 实现代码块的右移功能

tab键实现接受代码补全的提示	 		
ESC 实现展示或者隐藏代码提示补全菜单		

control + . 循环定位提示补全菜单项目，向前提示

control + shift + .循环定位提示补全菜单项目，向后提示
 
command + control + s 创建一个快照		
control + F 向前移动光标， 每次一个字符		
control + B 向后移动光标， 每次一个字符		
control + P 前当前光标向上移动一行		
control + N 将当前光标向下移动一行			
control + A 将当前光标移动到行首 		
control + E 将当前光标移动到行尾		
control + D 删除当前光标所在位置右边的一个字符		
control + K  删除当前光标之后的所有内容		
command + shift + delete  删除当前光标之前的整行内容		
command + Y 用于激活和取消激活断点		
command + shift + O 打开快速预览窗口， 可以在这个窗开直接打开查找的源文件		
### 谈谈你对OC程序语言，内存管理的机制的理解
对于这个问题， 需要回答4点内容
内存管理机制， 采用的引用计数技术， 或者又叫保留计数  
1. 每一个对象都有与之关联的整数，我们称这个整数为引用计数器或者保留计数器  
2. 当某段代码或者某个对象，需要访问这个对象的话，会将此对象的引用计数器加1  
3. 当某段代码或者某个对象，不需要访问这个对象的话， 会将此对象的引用计数器减1  
4. 当此对象的引用计数器变为0的时候， 表示再也不有代码或者对象访问此对象， 所以对象会自动发送dealloc消息， 其生命周期结束。其占用  的内存会被系统回收。

### 什么是自动释放池，机制是什么？
自动释放器类似于一个容器（实际上类似于栈的数据结构），当一个对象， 不能够确定他在什么时候销毁， 或者说使用销毁会代码实现变得更加复杂， 此时就可以向对象发送一个autorelease 消息， 那么此对象将会被放到自动释放池里， 当自动释放池销毁的时候，会向池子里的所有对象发送一个release消息， 来确保对象内存的销毁。那么自动释放器销毁是有规律的， 通常都是在一个事件循环自动完成之后， 进行销毁和创建。
**需要强调的是：在iPhone应用程序开发过程中， 尽量不要使用自动释放池**

### 手动管理内存的规则是什么？
1､ 如果创建了一个对象， 就必须考虑到要释放这个对象。如果使用了new , alloc , copy 方法获得到了一个对象， 则必须释放或者是自动释放此对象。   
2. 如果对创建的对象，发送了retain消息，那么必须对此对象发送release消息，保证retain 和 release的使用次数是相同。   

3.鉴于，new , alloc , copy方法的特殊性， 所以我们程序中一般的方法， 不要使用这个三个关键字开头， 除非我们的方法也是创建对象。   





